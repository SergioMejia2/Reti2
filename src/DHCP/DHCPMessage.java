package DHCP;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Hashtable;
import DHCP.DHCPOption;
import Pool.Pool;
import java.net.UnknownHostException;
import java.util.Map;


/**
 * This class represents a DHCP application level message packet 
 */

/**
 * @author Laivz
 *
 */
public class DHCPMessage {
	private static final int BOOTREQUEST = 1;
	private static final int BOOTREPLY = 2;
	private static final int DHCPREQUEST = 1;
	private static final int DHCPREPLY = 2;
	private static final int ETHERNET10MB = 1;
	
	//Operation Code:
	//Specifies the general type of message
	private byte op; 
	
	//Hardware Type:
	//Specifies the type of hardware used for the local network
	private byte hType; 
	
	//Hardware Address Length: 
	//Specifies how long hardware addresses are in this message. 
	private byte hLen;
	
	//Hops: 
	private byte hops;
	
	//Transaction Identifier: (32-bit)
	//Identification field generated by client
	//private byte[] xid = new byte[3];
	private int xid;
	
	//Seconds: (16-bit)
	//Number of seconds elapsed since a client began an attempt to acquire or renew a lease. 
	//private byte[] secs = new byte[1];
	private short secs;
	
	//Flags: (16-bit)
	//1bit broadcast flag (0-1)
	//15 bit reserverd
	//private byte[] flags = new byte[1];
	private short flags;
	
	//Client IP Address: (32-bit)
	private byte[] cIAddr;
	//private InetAddress cIAddr = new Inet4Address();

	//"Your" IP Address: (32-bit)
	private byte[] yIAddr;
	//Server IP Address: (32-bit)
	private byte[] sIAddr;
	//Gateway IP Address: (32-bit)
	private byte[] gIAddr;
	
	//Client Hardware Address: (128-bit : 16 bytes)
	private byte[] cHAddr;
	
	//Server Name: (512-bit : 64 bytes)
	private byte[] sName;
	
	//Boot Filename: (1024-bit : 128 bytes)
	private byte[] file;
	
        private byte[] magicCookie;
        
	//Options: (variable)
	private Hashtable<Byte,DHCPOption> options;
        
	

	public DHCPMessage() {
		cIAddr = new byte[4];
		yIAddr = new byte[4];
		sIAddr = new byte[4];
		gIAddr = new byte[4];
		cHAddr = new byte[16];
		sName = new byte[64];
		file = new byte[128];
		options = new Hashtable<Byte,DHCPOption>();
		//this.printMessage();
	}
        
        public DHCPMessage(byte[] message, int length)
        {
            cIAddr = new byte[4];
            yIAddr = new byte[4];
            sIAddr = new byte[4];
            gIAddr = new byte[4];
            cHAddr = new byte[16];
            sName = new byte[64];
            file = new byte[128];
            options = new Hashtable<Byte,DHCPOption>();

            op = message[0];
            hType = message[1];
            hLen = message[2];
            hops = message[3];
            ByteBuffer wrapped = ByteBuffer.wrap(Arrays.copyOfRange(message, 4, 8));
            xid = wrapped.getInt();
            wrapped = ByteBuffer.wrap(Arrays.copyOfRange(message, 8, 10));
            secs = wrapped.getShort();
            wrapped = ByteBuffer.wrap(Arrays.copyOfRange(message, 10, 12));
            flags = wrapped.getShort();
            cIAddr = Arrays.copyOfRange(message, 12, 16);
            yIAddr = Arrays.copyOfRange(message, 16, 20);
            sIAddr = Arrays.copyOfRange(message, 20, 24);
            gIAddr = Arrays.copyOfRange(message, 24, 28);
            cHAddr = Arrays.copyOfRange(message, 28, 44);
            sName = Arrays.copyOfRange(message, 44, 108);
            file = Arrays.copyOfRange(message, 108, 236);
            magicCookie = Arrays.copyOfRange(message, 236, 240);
            int i = 240;
            
            while(i < length)
            {
                byte opNumber;
                byte opLength; //0-255
                byte[] opData;
                opNumber = message[i];
                i++;
                opLength = message[i];
                i++;
                
                int longi = opLength & 0xff;
               
                opData = Arrays.copyOfRange(message, i, i+longi); 
                i += longi;
                DHCPOption opcion = new DHCPOption(opLength, opData);
                options.put(opNumber, opcion);
            }

        }
        
        public byte[] offerMsg(DHCPMessage discoverMsg, Pool pool, byte[] ipAsignada) throws UnknownHostException
        {
            byte[] retorno = null;
            op = DHCPREPLY;
            hType = 1;
            hLen = 6;
            hops = 0;
            xid = discoverMsg.getXid();
            secs = 1;
            flags = 0;
            for(int i = 0; i < 4; i++) cIAddr[i] = 0;
            yIAddr = ipAsignada;
            sIAddr = InetAddress.getLocalHost().getAddress();
            gIAddr = pool.getGatewayIP();
            cHAddr = discoverMsg.getCHAddr();
            sName = discoverMsg.getSName();
            file = discoverMsg.getFile();
            magicCookie = discoverMsg.getMagicCookie();
            
            byte[] data = {DHCPOption.DHCPOFFER};
            DHCPOption msgType = new DHCPOption((byte)1, data );
            options.put((byte)53, msgType);
            
            byte[] subnet = pool.getMask();
            DHCPOption subnetMask = new DHCPOption((byte)4, subnet);
            options.put((byte)1,subnetMask);
            
            byte[] gateway = gIAddr;
            DHCPOption gatewayAddr = new DHCPOption((byte)gateway.length, gateway);
            options.put((byte)3,gatewayAddr);
            
            byte[] lease = Utils.Utils.intToBytes(pool.getTime());
            DHCPOption leaseTime = new DHCPOption((byte)4, lease);
            options.put((byte)51,leaseTime);
            
            byte[] myIp = InetAddress.getLocalHost().getAddress();
            DHCPOption serverIp = new DHCPOption((byte)4, myIp);
            options.put((byte)54,serverIp);
            
            byte[] dns = pool.getDNS();
            DHCPOption dnsAddr = new DHCPOption((byte)dns.length, dns);
            options.put((byte)6,dnsAddr);
            
            retorno = externalize();
            
            return retorno;
        }
        
        public byte[] ackMsg(DHCPMessage requestMsg, Pool pool, byte[] ipAsignada) throws UnknownHostException
        {
            byte[] retorno = null;
            op = DHCPREPLY;
            hType = 1;
            hLen = 6;
            hops = 0;
            xid = requestMsg.getXid();
            secs = 3;
            flags = 0;
            for(int i = 0; i < 4; i++) cIAddr[i] = 0;
            yIAddr = ipAsignada;
            sIAddr = InetAddress.getLocalHost().getAddress();
            gIAddr = pool.getGatewayIP();
            cHAddr = requestMsg.getCHAddr();
            sName = requestMsg.getSName();
            file = requestMsg.getFile();
            magicCookie = requestMsg.getMagicCookie();
            
            byte[] data = {DHCPOption.DHCPACK};
            DHCPOption msgType = new DHCPOption((byte)1, data );
            options.put((byte)53, msgType);
            
            byte[] subnet = pool.getMask();
            DHCPOption subnetMask = new DHCPOption((byte)4, subnet);
            options.put((byte)1,subnetMask);
            
            byte[] gateway = gIAddr;
            DHCPOption gatewayAddr = new DHCPOption((byte)gateway.length, gateway);
            options.put((byte)3,gatewayAddr);
            
            byte[] lease = Utils.Utils.intToBytes(pool.getTime());
            DHCPOption leaseTime = new DHCPOption((byte)4, lease);
            options.put((byte)51,leaseTime);
            
            byte[] myIp = InetAddress.getLocalHost().getAddress();
            DHCPOption serverIp = new DHCPOption((byte)4, myIp);
            options.put((byte)54,serverIp);
            
            byte[] dns = pool.getDNS();
            DHCPOption dnsAddr = new DHCPOption((byte)dns.length, dns);
            options.put((byte)6,dnsAddr);
            
            retorno = externalize();
            
            return retorno;
        }
        
        public byte[] nackMsg(DHCPMessage requestMsg, Pool pool) throws UnknownHostException
        {
            byte[] retorno = null;
            op = DHCPREPLY;
            hType = 1;
            hLen = 6;
            hops = 0;
            xid = requestMsg.getXid();
            secs = 3;
            flags = 0;
            for(int i = 0; i < 4; i++) cIAddr[i] = 0;
            yIAddr = requestMsg.getYIAddr();
            sIAddr = InetAddress.getLocalHost().getAddress();
            gIAddr = pool.getGatewayIP();
            cHAddr = requestMsg.getCHAddr();
            sName = requestMsg.getSName();
            file = requestMsg.getFile();
            magicCookie = requestMsg.getMagicCookie();
            
            byte[] data = {DHCPOption.DHCPNACK};
            DHCPOption msgType = new DHCPOption((byte)1, data );
            options.put((byte)53, msgType);
            
            byte[] subnet = pool.getMask();
            DHCPOption subnetMask = new DHCPOption((byte)4, subnet);
            options.put((byte)1,subnetMask);
            
            byte[] gateway = gIAddr;
            DHCPOption gatewayAddr = new DHCPOption((byte)gateway.length, gateway);
            options.put((byte)3,gatewayAddr);
            
            byte[] lease = Utils.Utils.intToBytes(pool.getTime());
            DHCPOption leaseTime = new DHCPOption((byte)4, lease);
            options.put((byte)51,leaseTime);
            
            byte[] myIp = InetAddress.getLocalHost().getAddress();
            DHCPOption serverIp = new DHCPOption((byte)4, myIp);
            options.put((byte)54,serverIp);
            
            byte[] dns = pool.getDNS();
            DHCPOption dnsAddr = new DHCPOption((byte)dns.length, dns);
            options.put((byte)6,dnsAddr);
            
            retorno = externalize();
            
            return retorno;
        }
	
        public byte[] nackMsg(Pool pool, byte[] ip, int ram) throws UnknownHostException
        {
            byte[] retorno = null;
            op = DHCPREPLY;
            hType = 1;
            hLen = 6;
            hops = 0;
            xid = ram;
            secs = 3;
            flags = 0;
            //for(int i = 0; i < 4; i++) cIAddr[i] = 0;
            cIAddr = ip;
            //for(int i = 0; i < 4; i++) yIAddr[i] = 0;
            yIAddr = ip;
            sIAddr = InetAddress.getLocalHost().getAddress();
            gIAddr = pool.getGatewayIP();
            for(int i = 0; i < 4; i++) cHAddr[i] = 0;
            //cHAddr = requestMsg.getCHAddr();
            for(int i = 0; i < 4; i++) sName[i] = 0;
            //sName = requestMsg.getSName();
            for(int i = 0; i < 4; i++) file[i] = 0;
            //file = requestMsg.getFile();
            magicCookie = new byte[]{(byte)0x63, (byte)0x82, (byte)0x53, (byte)0x63};
            
            byte[] data = {DHCPOption.DHCPNACK};
            DHCPOption msgType = new DHCPOption((byte)1, data );
            options.put((byte)53, msgType);
            
            byte[] subnet = pool.getMask();
            DHCPOption subnetMask = new DHCPOption((byte)4, subnet);
            options.put((byte)1,subnetMask);
            
            byte[] gateway = gIAddr;
            DHCPOption gatewayAddr = new DHCPOption((byte)gateway.length, gateway);
            options.put((byte)3,gatewayAddr);
            
            byte[] lease = Utils.Utils.intToBytes(pool.getTime());
            DHCPOption leaseTime = new DHCPOption((byte)4, lease);
            options.put((byte)51,leaseTime);
            
            byte[] myIp = InetAddress.getLocalHost().getAddress();
            DHCPOption serverIp = new DHCPOption((byte)4, myIp);
            options.put((byte)54,serverIp);
            
            byte[] dns = pool.getDNS();
            DHCPOption dnsAddr = new DHCPOption((byte)dns.length, dns);
            options.put((byte)6,dnsAddr);
            
            retorno = externalize();
            
            return retorno;
        }
        
	public byte[] discoverMsg(byte[] cMacAddress) {
		op = DHCPREQUEST;
		hType = ETHERNET10MB; // (0x1) 10Mb Ethernet
		hLen = 6; // (0x6)
		hops = 0; // (0x0)
		xid = 556223005; // (0x21274A1D)
		secs = 0;  // (0x0)
		flags = 0; // (0x0)
		// DHCP: 0............... = No Broadcast

		cIAddr = new byte[] { 0, 0, 0, 0 }; // 0.0.0.0
		yIAddr = new byte[] { 0, 0, 0, 0 }; // 0.0.0.0
		sIAddr = new byte[] { 0, 0, 0, 0 }; // 0.0.0.0
		gIAddr = new byte[] { 0, 0, 0, 0 }; // 0.0.0.0
		cHAddr = cMacAddress; // 08002B2ED85E
		sName = new byte[sName.length]; // <Blank>
		file = new byte[file.length]; // <Blank>
		// DHCP: Magic Cookie = [OK]
		// DHCP: Option Field (options)
		// DHCP: DHCP Message Type = DHCP Discover
		// DHCP: Client-identifier = (Type: 1) 08 00 2b 2e d8 5e
		// DHCP: Host Name = JUMBO-WS
		// DHCP: Parameter Request List = (Length: 7) 01 0f 03 2c 2e 2f 06
		// DHCP: End of this option field

		return this.externalize();
	}
	
	/**
	 * Converts a DHCPMessage object to a byte array.
	 * @return  a byte array with   information from DHCPMessage object.
	 */
	public byte[] externalize() {
		int staticSize = 240;
		byte[] options = externalizeOptions();
		int size = staticSize + options.length+1;
		byte[] msg = new byte[size];
		
		//add each field to the msg array
		//single bytes
		msg[0] = this.op;
		msg[1] = this.hType;
		msg[2] = this.hLen;
		msg[3] = this.hops;
		
		//add multibytes
		for (int i=0; i < 4; i++) msg[4+i] = Utils.Utils.intToBytes(xid)[i];
		for (int i=0; i < 2; i++) msg[8+i] = Utils.Utils.shortToByte(secs)[i];
		for (int i=0; i < 2; i++) msg[10+i] = Utils.Utils.shortToByte(flags)[i];
		for (int i=0; i < 4; i++) msg[12+i] = cIAddr[i];
		for (int i=0; i < 4; i++) msg[16+i] = yIAddr[i];
		for (int i=0; i < 4; i++) msg[20+i] = sIAddr[i];
		for (int i=0; i < 4; i++) msg[24+i] = gIAddr[i];
		for (int i=0; i < 16; i++) msg[28+i] = cHAddr[i];
		for (int i=0; i < 64; i++) msg[44+i] = sName[i];
		for (int i=0; i < 128; i++) msg[108+i] = file[i];
		for (int i=0; i < 4; i++) msg[236+i] = magicCookie[i];
		//add options
		for (int i=0; i < options.length; i++) msg[staticSize+i] = options[i];
                msg[size-1] = (byte)0xff;
		return msg;
	}

	public byte getOp() {
		return op;
	}

	public void setOp(byte op) {
		this.op = op;
	}

	public byte getHType() {
		return hType;
	}

	public void setHType(byte type) {
		hType = type;
	}

	public byte getHLen() {
		return hLen;
	}

	public void setHLen(byte len) {
		hLen = len;
	}

	public byte getHops() {
		return hops;
	}

	public void setHops(byte hops) {
		this.hops = hops;
	}

	public int getXid() {
		return xid;
	}

	public void setXid(int xid) {
		this.xid = xid;
	}

	public short getSecs() {
		return secs;
	}

	public void setSecs(short secs) {
		this.secs = secs;
	}

	public short getFlags() {
		return flags;
	}

	public void setFlags(short flags) {
		this.flags = flags;
	}

	public byte[] getCIAddr() {
		return cIAddr;
	}

	public void setCIAddr(byte[] addr) {
		cIAddr = addr;
	}

	public byte[] getYIAddr() {
		return yIAddr;
	}

	public void setYIAddr(byte[] addr) {
		yIAddr = addr;
	}

	public byte[] getSIAddr() {
		return sIAddr;
	}

	public void setSIAddr(byte[] addr) {
		sIAddr = addr;
	}

	public byte[] getGIAddr() {
		return gIAddr;
	}

	public void setGIAddr(byte[] addr) {
		gIAddr = addr;
	}

	public byte[] getCHAddr() {
		return cHAddr;
	}

	public void setCHAddr(byte[] addr) {
		cHAddr = addr;
	}

	public byte[] getSName() {
		return sName;
	}

	public void setSName(byte[] name) {
		sName = name;
	}

	public byte[] getFile() {
		return file;
	}

	public void setFile(byte[] file) {
		this.file = file;
	}

	public byte[] getOptions() {
		return externalizeOptions();
	}

	//no set options yet...
	/*public void setOptions(byte[] options) {
		this.options = options;
	}*/
	
	public void printMessage() {
		System.out.println(this.toString());
	}
        
        public DHCPOption getOptionIn(int opNum)
        {
            for (Map.Entry<Byte, DHCPOption> entry : options.entrySet())
            {
                Byte key = entry.getKey();
                DHCPOption value = entry.getValue();
                int keyy = key & 0xff;
                if(keyy == opNum)
                {
                    return(value);
                }
            }
            return null;
        }
	
	@Override
	public String toString() {
		String msg = new String();
		
		msg += "Operation Code: " + this.op + "\n";
		msg += "Hardware Type: " + this.hType  + "\n";
		msg += "Hardware Length: " + this.hLen  + "\n";
		msg += "Hops: " + this.hops + "\n";
		
		msg += Integer.toString(xid) + "\n";
		msg += Short.toString(secs) + "\n";
		msg += Short.toString(flags) + "\n";
		msg += Utils.Utils.IPToString(cIAddr) + "\n";
		msg += Utils.Utils.IPToString(yIAddr) + "\n";
                msg += Utils.Utils.IPToString(sIAddr) + "\n";
		 msg += Utils.Utils.IPToString(gIAddr) + "\n";
		msg += Utils.Utils.bytesToString(cHAddr) + "\n";
		msg += Utils.Utils.bytesToString(sName) + "\n";
		 msg += Utils.Utils.bytesToString(file) + "\n";
		 
		 msg += optionsToString() + "\n";
		
		//add options
		 assert(file != null);
		 assert (options != null);
		//msg += options.toString();
		
		//return super.toString();
		return msg;
	}
	
	
    public byte[] externalizeOptions()
    {
        int tam = 0;
        for (Map.Entry<Byte, DHCPOption> entrySet : this.options.entrySet())
        {
            DHCPOption value = entrySet.getValue();
            tam += 2+value.getOpLength();
        }
        byte[] options = new byte[tam];
        int i = 0;
        for (Map.Entry<Byte, DHCPOption> entrySet : this.options.entrySet())
        {
            Byte key = entrySet.getKey();
            DHCPOption value = entrySet.getValue();
            options[i] = key;
            i++;
            options[i] = value.getOpLength();
            i++;
            for(int j = 0; j < value.getOpLength(); j++)
            {
                options[i] = value.getOpData()[j];
                i++;
            }
        }
        return options;
    }

    private String optionsToString()
    {
        String retorno = new String();
        for (Map.Entry<Byte, DHCPOption> entry : options.entrySet()) {
            Byte key = entry.getKey();
            DHCPOption value = entry.getValue();
            int llave = key & (0xff);
            retorno += "Option N° "+llave+"\n";
            retorno += "Length: "+value.getOpLength()+"\n";
            if(llave == 50 || llave==1 || llave==6 || llave==54)
            {
                retorno += "Data: "+Utils.Utils.IPToString(value.getOpData())+"\n\n"; 
            }
            else if(llave == 60)
            {
                retorno += "Data: "+Utils.Utils.BytesToText(value.getOpData())+"\n\n";
            }
            else
            {
                retorno += "Data: "+Utils.Utils.bytesToString(value.getOpData())+"\n\n";
            }
        }
        return retorno;
    }

    public byte[] getMagicCookie()
    {
        return this.magicCookie;
    }
	
}